<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>  
<#@ assembly name="System.Linq" #>  
<#@ assembly name="System.Core" #>  
<#@ import namespace="System.Collections.Generic" #>  
<#@ import namespace="System.Linq" #>  
<#@ import namespace="System.Reflection" #>  
<#@ import namespace="System" #>  
<#@ assembly name="$(SolutionDir)Benchmark\bin\Debug\net47\win7-x86\Benchmark.exe" #>
<# 
   var serializers = typeof(Benchmark.Serializers.SerializerBase).Assembly
                .GetTypes()
                .Where(t => !t.IsAbstract && typeof(Benchmark.Serializers.SerializerBase).IsAssignableFrom(t))
                .ToList();
	var models = typeof(Benchmark.Serializers.SerializerBase).Assembly
                .GetTypes()
                .Where(t => t.Namespace == "Benchmark.Models" && !t.IsEnum && !t.IsInterface && !t.IsAbstract)
                .ToList();
#>  
namespace Benchmark
{  
using Benchmark.Serializers;
using Benchmark.Models;
using Benchmark.Fixture;
using BenchmarkDotNet.Attributes;
  public partial class ModelBenchmark<TSerializer> where TSerializer : SerializerBase, new()
  {
	private readonly static ExpressionTreeFixture ExpressionTreeFixture = new ExpressionTreeFixture();
<#  
    foreach(var serializer in serializers)
    { 
#>  
	private readonly static <#= serializer.FullName #> <#= serializer.Name #> = new <#= serializer.FullName #>();
<#  
    }   
#>  
<#  
    foreach(var model in models)
    { 
		var fullNameFixed = model.FullName.Replace('+','.');		
#>  
	private readonly static <#= fullNameFixed #> <#= model.Name #>Input = ExpressionTreeFixture.Create<<#= fullNameFixed #>>();
<#  
    }   
#>  
<#  
	foreach(var serializer in serializers)
	{
    foreach(var model in models)
    {  
		var fullNameFixed = model.FullName.Replace('+','.');		
#>  
	private readonly static string <#= model.Name #>OutputOf<#= serializer.Name #> = <#= serializer.Name #>.Serialize(<#= model.Name #>Input);

	[Benchmark]
	public string Serialize<#= model.Name #>With<#= serializer.Name #>()
	{
		return <#= serializer.Name #>.Serialize(<#= model.Name #>Input);
	}
	[Benchmark]
	public object Deserialize<#= model.Name #>With<#= serializer.Name #>()
	{
		return <#= serializer.Name #>.Deserialize<<#= fullNameFixed #>>(<#= model.Name #>OutputOf<#= serializer.Name #>);
	}
<#  
    }   
	}
#> 

  }
}
  